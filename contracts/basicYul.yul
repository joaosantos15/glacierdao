// SPDX-License-Identifier: GPL-3.0

/** 
    To Learn

    1. constructor
    2. yul doesn't have to respect call data
    3. how to compile yul
    4. how to interact with yul
    5. custom code in the constructor

**/


/*
 let _gas = stack.pop();
    let dst = stack.pop();
    let value = stack.pop();
    let method = stack.pop();
    let input_offset = stack.pop();
    let input_size = stack.pop();
*/

// PUSH1 input_size PUSH1 input_offset  PUSH1 method PUSH1 value PUSH1 dst PUSH1 _gas

/* 
PUSH32 input_size // is this the size of value in bytes?
PUSH32 input_offset // is this 32 bytes input_size + 32 bytes input_offset + 32 bytes method + 32 bytes value ?
PUSH32 0x42 // method
PUSH32 0x0 // value: we're not sending any tokens
PUSH32 0xff00000000000000000000000000000000000005 // dst
PUSH32 0x0 // _gas they say the gas limit is not used now
CALLACTOR 
*/

/* 
7F07F07F427F07Fff000000000000000000000000000000000000057F0b0 
*/

/* 
0x7F 0x00000000000000000000000000000000
0x7F 0x00000000000000000000000000000000 
0x7F 0x00000000000000000000000000000042
0x7F 0x00000000000000000000000000000000
0x7F 0xff00000000000000000000000000000000000005
0x7F 0x00000000000000000000000000000000
0x00000000000000000000000000000000000b0
*/

/* 
7F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000427F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ff000000000000000000000000000000000000057F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b0
*/


object "Simple" {
    code {
        datacopy(0, dataoffset("runtime"), datasize("runtime"))
        return(0, datasize("runtime"))        
    }

    object "runtime" {
        
        code {
            let x := calldataload(0)
            let double := verbatim_1i_1o(hex"712121", x)  // this is I'm trying out a bunch of stuff to see what generates a compiled bytecode like what we have in lines 30-36
            mstore(0x00, double)
            return(0x00, 0x20)
        }
    }
}
